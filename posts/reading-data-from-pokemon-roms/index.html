<!doctype html><html lang=en-us><head><title>Reading Data From Pokemon ROMs // EmberQuill's Website</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.115.4"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="EmberQuill"><meta name=description content><link rel=stylesheet href=/css/main.min.aab4576dcd5604cebd4e6166033bf225ad08056508365837649bccff6a4ef807.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Reading Data From Pokemon ROMs"><meta name=twitter:description content="This is going to be a long one. Let&rsquo;s talk about Pokemon ROM hacking.
First, if you don&rsquo;t know what a ROM hack is, basically it&rsquo;s just a modified or &ldquo;hacked&rdquo; game. Not necessarily for the sake of cheating, though, which is what usually comes to mind when someone talks about hacked games. In fact, many ROM hacks are significantly more difficult than the original games they&rsquo;re based on. ROM hacks exist for many reasons, but that&rsquo;s not really the point of this post so if you really want to learn more, Bulbapedia has a great article on the subject."><meta property="og:title" content="Reading Data From Pokemon ROMs"><meta property="og:description" content="This is going to be a long one. Let&rsquo;s talk about Pokemon ROM hacking.
First, if you don&rsquo;t know what a ROM hack is, basically it&rsquo;s just a modified or &ldquo;hacked&rdquo; game. Not necessarily for the sake of cheating, though, which is what usually comes to mind when someone talks about hacked games. In fact, many ROM hacks are significantly more difficult than the original games they&rsquo;re based on. ROM hacks exist for many reasons, but that&rsquo;s not really the point of this post so if you really want to learn more, Bulbapedia has a great article on the subject."><meta property="og:type" content="article"><meta property="og:url" content="https://emberquill.com/posts/reading-data-from-pokemon-roms/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-10T20:45:00-04:00"><meta property="article:modified_time" content="2023-07-28T11:08:40-04:00"></head><body><header class=app-header><a href=https://emberquill.com><img class=app-header-avatar src=/images/avatar.png alt=EmberQuill></a>
<span class=app-header-title>EmberQuill's Website</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
&mdash;
<a class=app-header-menu-item href=/tags>Tags</a>
&mdash;
<a class=app-header-menu-item href=/about>About</a></nav><p>I talk about dev stuff.</p><div class=app-header-social><a href=https://github.com/emberquill target=_blank rel="noreferrer noopener me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><a href=https://tech.lgbt/@emberquill target=_blank rel="noreferrer noopener me"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mastodon"><title>Mastodon</title><path d="M23.3 5.3A6.2 6.2.0 0018 .3c-.5.0-2.2-.3-6.2-.3S6.9.2 6.5.3C3.9.7 1.5 2.5.9 5.1a53.3 53.3.0 000 9.7l.6 3.6c.6 2.3 2.8 4.1 5 4.9a13.4 13.4.0 008 .2c.6-.2 1.3-.4 1.8-.8v-1.9a20.3 20.3.0 01-4.7.5c-2.8.0-3.5-1.2-3.7-1.8a5.6 5.6.0 01-.3-1.4c1.6.3 3.1.5 4.7.5h1.1a30 30 0 004.8-.4c2.5-.5 4.8-2 5-5.7V11c0-.6.3-3.7.0-5.6zm-3.8 9.2H17V8.3c0-1.3-.6-2-1.7-2-1.2.0-1.9.8-1.9 2.4V12H11V8.7c0-1.6-.6-2.4-1.9-2.4-1 0-1.6.7-1.6 2v6.2H4.8V8.1a5 5 0 011-3.1c.7-.8 1.6-1.2 2.8-1.2 1.3.0 2.3.5 3 1.5l.6 1 .6-1c.7-1 1.7-1.5 3-1.5 1.1.0 2 .4 2.7 1.2.7.8 1 1.8 1 3.1z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Reading Data From Pokemon ROMs</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 10, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>15 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentcolor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://emberquill.com/tags/pokemon/>Pokemon</a>
<a class=tag href=https://emberquill.com/tags/python/>Python</a></div></div></header><div class=post-content><p>This is going to be a long one. Let&rsquo;s talk about Pokemon ROM hacking.</p><p>First, if you don&rsquo;t know what a ROM hack is, basically it&rsquo;s just a modified or &ldquo;hacked&rdquo; game. Not necessarily for the sake of cheating, though, which is what usually comes to mind when someone talks about hacked games. In fact, many ROM hacks are significantly more difficult than the original games they&rsquo;re based on. ROM hacks exist for many reasons, but that&rsquo;s not really the point of this post so if you really want to learn more, Bulbapedia has a <a href=https://bulbapedia.bulbagarden.net/wiki/ROM_hacks>great article</a> on the subject.</p><p>Anyway, I recently started playing a few different ROM hacks based on Pokemon Emerald. They&rsquo;re mostly similar in terms of added features, including things such as the Physical/Special split originally introduced in Generation IV, making all Pokemon obtainable without trading, running indoors, capping EVs at 252, etc. But many ROM hacks are more ambitious than just simple quality-of-life improvements, modifying things like Pokemon base stats, movesets, and abilities to reflect changes made in subsequent Pokemon games.</p><p>And many of them change where you can find certain Pokemon, especially in order to make it possible to fill the National Pokedex without trading. For example, in <a href="https://www.pokecommunity.com/showthread.php?t=410480">Pokemon Emerald Final</a>, you can catch all of the starter Pokemon from the first three Generations in the Safari Zone.</p><p>So how do you know where to look to track down an elusive Pokemon? The official games have strategy guides, fansites, and people who have decompiled the game and discovered every last secret contained within. ROM hacks only have whatever documentation was provided with them. Normally, that is enough. Most ROM hacks provide very detailed information about the changes they made, so this isn&rsquo;t usually an issue. But some ROM hacks, especially very old or less popular ones, might not have documentation, or might have old/outdated information that no longer applies, or might even have been deleted from wherever they were hosted if it&rsquo;s a very old hack.</p><p>But the information is in the game itself, if you know where to find it. So I decided to figure out how to find it.</p><h3 id=resources>Resources</h3><p>There is no single, comprehensive guide to parsing and decoding data within ROMs, so I had to assemble information from several different sources, including:</p><ul><li>Bulbapedia<ul><li><a href=https://bulbapedia.bulbagarden.net/wiki/Wild_Pok%C3%A9mon>Wild Pokemon</a> for some information about spawn mechanics</li><li><a href=https://bulbapedia.bulbagarden.net/wiki/Character_encoding_(Generation_III)>Character Encoding</a> because they didn&rsquo;t use unicode until Black/White</li></ul></li><li>PokeCommunity Forum<ul><li><a href="https://www.pokecommunity.com/showthread.php?t=435641">Spawn Chances</a></li><li><a href="https://www.pokecommunity.com/showthread.php?p=7650568#post7650568">Encounter Data</a> (note that this post is slightly inaccurate and is corrected a few posts later)</li></ul></li><li><a href=https://datacrystal.romhacking.net/wiki/Pok%C3%A9mon_3rd_Generation>Pokemon 3rd Generation</a> page on the Data Crystal ROM Hacking wiki</li></ul><p>I also ended up downloading a ROM hacking tool called <a href=https://gbatemp.net/download/advance-map.8622/>Advance Map</a>, because its configuration files contain information about where to find data in the ROM.</p><p>As for the necessary tools, you&rsquo;ll need a Hex Editor at the very least. Coding knowledge helps as well, as you can simplify some of the steps with some scripts. I&rsquo;ll be using Python in any code examples, but any language that can read binary files (so probably all of them) will suffice.</p><h3 id=getting-started>Getting Started</h3><p>The first thing we have to do is figure out where to look for the data we need. We can find that information by examining the configuration files that come with another ROM hacking tool such as Advance Map, linked above in the <strong>Resources</strong> section. If you download the tool and browse to the <strong>Ini</strong> folder, you&rsquo;ll see a list of configuration files. <code>AdvanceMap.ini</code> contains the information we need. The first few lines look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#66d9ef>[Allgemein]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#a6e22e>AMVersion</span><span style=color:#f92672>=</span><span style=color:#e6db74>1.92</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#a6e22e>BekannteRomTypen</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPR,BPG,BPE,AXP,AXV</span>
</span></span></code></pre></div><p>I don&rsquo;t know German, so I put &ldquo;Allgemein&rdquo; and &ldquo;Bekannte Rom Typen&rdquo; into Google Translate and got this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#66d9ef>[General]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#a6e22e>AMVersion</span><span style=color:#f92672>=</span><span style=color:#e6db74>1.92</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#a6e22e>KnownRomTypes</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPR,BPG,BPE,AXP,AXV</span>
</span></span></code></pre></div><p>Okay, that&rsquo;s a good start. Now let&rsquo;s figure out what those ROM codes are. There are five of them, just as there are five Pokemon main-series games on the GameBoy Advance. (Ruby, Sapphire, Emerald, FireRed, and LeafGreen). So which three-letter code corresponds to which game? For that, we&rsquo;ll need to look at the game itself. The ROM code is stored at the address <code>0xac</code> in all of the Generation III ROMS. If you open up Pokemon Emerald and read three bytes from that address, you&rsquo;ll get the code for that ROM:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;emerald.gba&#39;</span>, <span style=color:#e6db74>&#39;rb&#39;</span>) <span style=color:#66d9ef>as</span> infile:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     _ <span style=color:#f92672>=</span> infile<span style=color:#f92672>.</span>seek(<span style=color:#ae81ff>0xac</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     infile<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;BPE&#39;</span>
</span></span></code></pre></div><p>So, <code>BPE</code> corresponds to Pokemon Emerald. All ROM hacks based on Emerald should have the same three bytes at this location. Looking at dumps of the other Pokemon games, we can determine that the codes are:</p><table><thead><tr><th>Code</th><th>Game</th></tr></thead><tbody><tr><td>BPR</td><td>FireRed</td></tr><tr><td>BPG</td><td>LeafGreen</td></tr><tr><td>BPE</td><td>Emerald</td></tr><tr><td>AXP</td><td>Sapphire</td></tr><tr><td>AXV</td><td>Ruby</td></tr></tbody></table><p>So, with that out of the way, we first need to find out where to start looking. We want to find out what wild Pokemon are available in each location in the game. If you scroll down a bit in the same INI file as before, you&rsquo;ll find this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">119</span><span><span style=color:#66d9ef>[WildePokemon]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">120</span><span><span style=color:#a6e22e>art</span><span style=color:#f92672>=</span><span style=color:#e6db74>pointer</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">121</span><span><span style=color:#a6e22e>nach</span><span style=color:#f92672>=</span><span style=color:#e6db74>0348048009E00000FFFF0000</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">122</span><span><span style=color:#a6e22e>spiele</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPR,BPG,BPE,AXP,AXV</span>
</span></span></code></pre></div><p>The meaning of <code>WildePokemon</code> should be fairly clear, and <code>spiele</code> translates to &ldquo;games&rdquo; and has a value containing all five ROM codes, signifying that this value applies to all five games. The value we&rsquo;re most interested in though is the <code>nach</code> value, which contains a 12-byte hexadecimal string:</p><p><code>03 48 04 80 09 e0 00 00 ff ff 00 00</code></p><p>This value is a header that we need to search for in the file. We can find the address by just searching through the data, since the Emerald ROM is only 16MiB in size.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;emerald.gba&#39;</span>, <span style=color:#e6db74>&#39;rb&#39;</span>) <span style=color:#66d9ef>as</span> infile:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     data <span style=color:#f92672>=</span> infile<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> data<span style=color:#f92672>.</span>find(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x03\x48\x04\x80\x09\xe0\x00\x00\xff\xff\x00\x00</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>742740</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> hex(<span style=color:#ae81ff>742740</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;0xb5554&#39;</span>
</span></span></code></pre></div><p>So the header we are searching for begins at the address <code>0xb5554</code>. After the 12-byte header is a pointer to the start of the encounter data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> data[<span style=color:#ae81ff>0xb5554</span><span style=color:#f92672>+</span><span style=color:#ae81ff>12</span>:<span style=color:#ae81ff>0xb5554</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;H-U</span><span style=color:#ae81ff>\x80</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> binascii
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> binascii<span style=color:#f92672>.</span>hexlify(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;H-U</span><span style=color:#ae81ff>\x80</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;482d5508&#39;</span>
</span></span></code></pre></div><p>GBA ROMs store data in &ldquo;little-endian&rdquo; format, which means the least significant byte is first. In other words, a value of <code>48 2d 55 08</code> as seen in the above code block is actually a pointer to <code>0x08552d48</code>.</p><p>GBA games are loaded into the GBA&rsquo;s RAM at offset <code>0x08000000</code>, which means any pointers will start from that address instead of <code>0x00</code>. The easiest way to convert a pointer to a format that works for an unloaded ROM file is to just zero out the first byte. So the actual address that we should look for is <code>0x00552d48</code>. At that address, we will find the start of the wild encounter data.</p><h3 id=wild-encounter-data>Wild Encounter Data</h3><p>Encounter Data is stored in a list of 20-byte blocks starting at <code>0x00552d48</code>. This sequence of blocks is terminated by a block that starts with <code>ff ff</code> with the remaining 18 bytes filled with null (<code>00</code>) bytes.</p><p>So let&rsquo;s look at the first block of Encounter Data in Pokemon Emerald:</p><p><code>00 10 00 00 14 08 55 08 00 00 00 00 00 00 00 00 00 00 00 00</code></p><p>The format of each block is as follows:</p><table><thead><tr><th>Byte</th><th>Data</th><th>Example</th></tr></thead><tbody><tr><td>0</td><td>Bank Number</td><td><code>00</code></td></tr><tr><td>1</td><td>Map Number</td><td><code>10</code></td></tr><tr><td>2-3</td><td>Filler/Empty</td><td><code>00 00</code></td></tr><tr><td>4-7</td><td>Grass Pointer</td><td><code>14 08 55 08</code></td></tr><tr><td>8-11</td><td>Surfing Pointer</td><td><code>00 00 00 00</code></td></tr><tr><td>12-15</td><td>Rock Smash Pointer</td><td><code>00 00 00 00</code></td></tr><tr><td>16-19</td><td>Fishing Pointer</td><td><code>00 00 00 00</code></td></tr></tbody></table><p>The Bank and Map numbers are used as a unique identifier for each map in the game, and will be used later on to find more information about a location including its name. The four pointers point to encounter data for tall grass, surfing, rock smash/headbutt, and fishing encounters. Since all of them other than the grass pointer are empty in this example, we can conclude that there is no accessible water or breakable rocks on this map.</p><p>The grass pointer is <code>0x00550814</code>. At that address we will find the following 8-byte block:</p><p><code>14 00 00 00 e4 07 55 08</code></p><p>The first byte, <code>14</code>, is the encounter rate. It&rsquo;s a base 16 hexadecimal number, so if we convert it to base 10, we get <code>20</code>. Every time you step on a tall grass tile (or, for the other encounter types, surf into a water tile, break a rock, or use a fishing rod), the game will use this value to calculate whether an encounter should trigger. First it generates a random number from 0 to 2879 (inclusive), then compares this number to the encounter rate multiplied by 16. If the random number is lower, an encounter is triggered.</p><p>In Python, that kind of function could be defined like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> random <span style=color:#f92672>import</span> randint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>trigger_encounter</span>(encounter_rate: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> encounter_rate <span style=color:#f92672>*</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>&gt;</span> randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2879</span>)
</span></span></code></pre></div><p>For this map, there is approximately a 11.111% chance of triggering an encounter when you step on a grass tile:</p><p><code>20 * 16 / 2880 = 0.11111...</code></p><p>The next three bytes are empty filler bytes. The second half of this block is another pointer, which points to the actual start of the encounter data: <code>0x005507e4</code></p><p>At that address is a 48-byte block, with four bytes per Pokemon for a total of up to 12 Pokemon. Each of the 12 slots has a set chance to occur when an encounter is triggered. The full block of data in this example is:</p><pre tabindex=0><code>02 02 22 01 02 02 1e 01 02 02 22 01 03 03 22 01
03 03 1e 01 03 03 1e 01 03 03 22 01 03 03 1e 01
02 02 20 01 02 02 20 01 03 03 20 01 03 03 20 01
</code></pre><p>Split into four-byte chunks, it looks like this:</p><table><thead><tr><th>Byte</th><th>Chance</th><th>Data</th></tr></thead><tbody><tr><td>0-3</td><td>20%</td><td><code>02 02 22 01</code></td></tr><tr><td>4-7</td><td>20%</td><td><code>02 02 1e 01</code></td></tr><tr><td>8-11</td><td>10%</td><td><code>02 02 22 01</code></td></tr><tr><td>12-15</td><td>10%</td><td><code>03 03 22 01</code></td></tr><tr><td>16-19</td><td>10%</td><td><code>03 03 1e 01</code></td></tr><tr><td>20-23</td><td>10%</td><td><code>03 03 1e 01</code></td></tr><tr><td>24-27</td><td>5%</td><td><code>03 03 22 01</code></td></tr><tr><td>28-31</td><td>5%</td><td><code>03 03 1e 01</code></td></tr><tr><td>32-35</td><td>4%</td><td><code>02 02 20 01</code></td></tr><tr><td>36-39</td><td>4%</td><td><code>02 02 20 01</code></td></tr><tr><td>40-43</td><td>1%</td><td><code>03 03 20 01</code></td></tr><tr><td>44-47</td><td>1%</td><td><code>03 03 20 01</code></td></tr></tbody></table><p>The encounter chances are hard-coded in the game. The first two slots of every grass encounter block each have a 20% chance, the next four have a 10% chance, etc.</p><p>Each four-byte slot has the minimum level in the first byte, the maximum level in the second byte, and an index number of the Pokemon as the remaining two bytes. The index number does not exactly correspond with the National Pokedex number of a Pokemon, unfortunately, due to the way Pokemon are stored in the Generation III games. There are several empty slots between Celebi and Treecko and some of the Pokemon aren&rsquo;t in the same order as the National Dex. Because of this, as well as the fact that ROM hacks can add or chance Pokemon, we will need to read the list of Pokemon from the ROM as well, rather than relying on external information. But in the mean time, we have this data so far:</p><table><thead><tr><th>Data</th><th>Chance</th><th>Number</th><th>Min Lvl</th><th>Max Lvl</th></tr></thead><tbody><tr><td><code>02 02 22 01</code></td><td>20%</td><td>290</td><td>2</td><td>2</td></tr><tr><td><code>02 02 1e 01</code></td><td>20%</td><td>286</td><td>2</td><td>2</td></tr><tr><td><code>02 02 22 01</code></td><td>10%</td><td>290</td><td>2</td><td>2</td></tr><tr><td><code>03 03 22 01</code></td><td>10%</td><td>290</td><td>3</td><td>3</td></tr><tr><td><code>03 03 1e 01</code></td><td>10%</td><td>286</td><td>3</td><td>3</td></tr><tr><td><code>03 03 1e 01</code></td><td>10%</td><td>286</td><td>3</td><td>3</td></tr><tr><td><code>03 03 22 01</code></td><td>5%</td><td>290</td><td>3</td><td>3</td></tr><tr><td><code>03 03 1e 01</code></td><td>5%</td><td>286</td><td>3</td><td>3</td></tr><tr><td><code>02 02 20 01</code></td><td>4%</td><td>290</td><td>2</td><td>2</td></tr><tr><td><code>02 02 20 01</code></td><td>4%</td><td>290</td><td>2</td><td>2</td></tr><tr><td><code>03 03 20 01</code></td><td>1%</td><td>290</td><td>3</td><td>3</td></tr><tr><td><code>03 03 20 01</code></td><td>1%</td><td>290</td><td>3</td><td>3</td></tr></tbody></table><p>Numbers, like pointers, are stored in little-endian format. So <code>22 01</code> translates to <code>0x0122</code>, which is <code>290</code> in base 10.</p><h3 id=pokemon-names>Pokemon Names</h3><p>Luckily, it&rsquo;s not hard to find the list of Pokemon names. First let&rsquo;s look back at <code>AdvanceMap.ini</code> again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">152</span><span><span style=color:#66d9ef>[PokemonNamen]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">153</span><span><span style=color:#a6e22e>inkSprache</span><span style=color:#f92672>=</span><span style=color:#e6db74>1</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">154</span><span><span style=color:#a6e22e>art</span><span style=color:#f92672>=</span><span style=color:#e6db74>pointer</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">155</span><span><span style=color:#a6e22e>vor</span><span style=color:#f92672>=</span><span style=color:#e6db74>30B50025084CC8F7</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">156</span><span><span style=color:#a6e22e>spiele</span><span style=color:#f92672>=</span><span style=color:#e6db74>AXPJ,AXVJ,AXPE,AXVE</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">157</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">158</span><span><span style=color:#66d9ef>[PokemonNamen2]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">159</span><span><span style=color:#a6e22e>art</span><span style=color:#f92672>=</span><span style=color:#e6db74>pointer</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">160</span><span><span style=color:#a6e22e>position</span><span style=color:#f92672>=</span><span style=color:#e6db74>$000144</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">161</span><span><span style=color:#a6e22e>spiele</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPR,BPG,BPE,AXP,AXV</span>
</span></span></code></pre></div><p>If we look at the <code>spiele</code> values for these two sections, the bottom one (<code>PokemonNamen2</code>) is the one we want as it contains the <code>BPE</code> code for Emerald. The <code>position</code> value is different from the <code>nach</code> value we saw before that contained a header. This one contains a pointer itself, pointing to <code>0x00000144</code>. If we read the four bytes from that address in the Emerald game, we get another pointer: <code>0x003185c8</code>. At that address, we will find the start of the Pokemon Names list. Each name is exactly 11 bytes long, terminated by an <code>ff</code> byte. If the name is shorter than 10 characters, the rest of the space will be padded with <code>00</code>. After the last name in the list is a &ldquo;name&rdquo; that contains only a single <code>ae</code> byte: <code>ae ff 00 00 00 00 00 00 00 00 00</code></p><p>So, the first encounter in the table above has an index number of 290. We can find the corresponding name for that Pokemon by seeking forward <code>290 * 11</code> bytes and reading the next 11 bytes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;emerald.gba&#39;</span>, <span style=color:#e6db74>&#39;rb&#39;</span>) <span style=color:#66d9ef>as</span> infile:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     _ <span style=color:#f92672>=</span> infile<span style=color:#f92672>.</span>seek(<span style=color:#ae81ff>0x144</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     pointer <span style=color:#f92672>=</span> int<span style=color:#f92672>.</span>from_bytes(infile<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>4</span>), <span style=color:#e6db74>&#39;little&#39;</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x08000000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     _ <span style=color:#f92672>=</span> infile<span style=color:#f92672>.</span>seek(pointer <span style=color:#f92672>+</span> <span style=color:#ae81ff>290</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>11</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     name_bytes <span style=color:#f92672>=</span> infile<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>11</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> name_bytes
</span></span><span style=display:flex><span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\xd1\xcf\xcc\xc7\xca\xc6\xbf\xff\x00\x00\x00</span><span style=color:#e6db74>&#39;</span>
</span></span></code></pre></div><p><code>ff</code> signifies the end of the name, and the rest of the field is padded with <code>00</code> bytes, so we chop off the last four bytes to get the actual name: <code>d1 cf cc c7 ca c6 bf</code></p><p>Later Pokemon games use unicode for text encoding, but back in Generation III they used a <a href=https://bulbapedia.bulbagarden.com/wiki/Character_encoding_(Generation_III)>custom character map</a> to save space. Decoding the above name with that character map gives us <code>WURMPLE</code> as a result.</p><p>Here is the encounter table from earlier, with the decoded Pokemon names included:</p><table><thead><tr><th>Data</th><th>Chance</th><th>Number</th><th>Name</th><th>Min Lvl</th><th>Max Lvl</th></tr></thead><tbody><tr><td><code>02 02 22 01</code></td><td>20%</td><td>290</td><td>Wurmple</td><td>2</td><td>2</td></tr><tr><td><code>02 02 1e 01</code></td><td>20%</td><td>286</td><td>Poochyena</td><td>2</td><td>2</td></tr><tr><td><code>02 02 22 01</code></td><td>10%</td><td>290</td><td>Wurmple</td><td>2</td><td>2</td></tr><tr><td><code>03 03 22 01</code></td><td>10%</td><td>290</td><td>Wurmple</td><td>3</td><td>3</td></tr><tr><td><code>03 03 1e 01</code></td><td>10%</td><td>286</td><td>Poochyena</td><td>3</td><td>3</td></tr><tr><td><code>03 03 1e 01</code></td><td>10%</td><td>286</td><td>Poochyena</td><td>3</td><td>3</td></tr><tr><td><code>03 03 22 01</code></td><td>5%</td><td>290</td><td>Wurmple</td><td>3</td><td>3</td></tr><tr><td><code>03 03 1e 01</code></td><td>5%</td><td>286</td><td>Poochyena</td><td>3</td><td>3</td></tr><tr><td><code>02 02 20 01</code></td><td>4%</td><td>290</td><td>Zigzagoon</td><td>2</td><td>2</td></tr><tr><td><code>02 02 20 01</code></td><td>4%</td><td>290</td><td>Zigzagoon</td><td>2</td><td>2</td></tr><tr><td><code>03 03 20 01</code></td><td>1%</td><td>290</td><td>Zigzagoon</td><td>3</td><td>3</td></tr><tr><td><code>03 03 20 01</code></td><td>1%</td><td>290</td><td>Zigzagoon</td><td>3</td><td>3</td></tr></tbody></table><p>Duplicate entries can be combined to give us this final result:</p><table><thead><tr><th>Pokemon</th><th>Level</th><th>Chance</th></tr></thead><tbody><tr><td>Wurmple</td><td>2</td><td>30%</td></tr><tr><td>Wurmple</td><td>3</td><td>15%</td></tr><tr><td>Poochyena</td><td>2</td><td>20%</td></tr><tr><td>Poochyena</td><td>3</td><td>25%</td></tr><tr><td>Zigzagoon</td><td>2</td><td>8%</td></tr><tr><td>ZigZagoon</td><td>3</td><td>2%</td></tr></tbody></table><p>This location does not have other encounter types for us to look at, but on maps where it&rsquo;s possible to surf, fish, and break rocks, the different encounter tables work in a similar way, though the number of slots and spread of spawn chances is different.</p><p>Surfing and Rock Smash both have five encounter slots, which have the following spawn chances:</p><table><thead><tr><th>Slot</th><th>Chance</th></tr></thead><tbody><tr><td>0</td><td>60%</td></tr><tr><td>1</td><td>30%</td></tr><tr><td>2</td><td>5%</td></tr><tr><td>3</td><td>4%</td></tr><tr><td>4</td><td>1%</td></tr></tbody></table><p>Fishing has 10 encounter slots, ordered by both rod quality and spawn chance:</p><table><thead><tr><th>Slot</th><th>Rod</th><th>Chance</th></tr></thead><tbody><tr><td>0</td><td>Old</td><td>70%</td></tr><tr><td>1</td><td>Old</td><td>30%</td></tr><tr><td>2</td><td>Good</td><td>60%</td></tr><tr><td>3</td><td>Good</td><td>20%</td></tr><tr><td>4</td><td>Good</td><td>20%</td></tr><tr><td>5</td><td>Super</td><td>40%</td></tr><tr><td>6</td><td>Super</td><td>30%</td></tr><tr><td>7</td><td>Super</td><td>15%</td></tr><tr><td>8</td><td>Super</td><td>10%</td></tr><tr><td>9</td><td>Super</td><td>5%</td></tr></tbody></table><h3 id=location-names>Location Names</h3><p>So, we have almost everything we need. We have a list of Pokemon with their names, level ranges, and spawn chances.</p><p>But we don&rsquo;t know which map it&rsquo;s for.</p><p>Now, we could figure it out pretty easily on our own by going to Bulbapedia or another website that shows spawn chances, and it wouldn&rsquo;t take much effort to determine that this is Route 101 based on the available Pokemon and their level ranges. But that doesn&rsquo;t help us if we&rsquo;re dissecting an undocumented ROM hack. So how do we get the map name?</p><p>First, let&rsquo;s go back to <code>AdvanceMap.ini</code> again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">113</span><span><span style=color:#66d9ef>[MapBankHeader]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">114</span><span><span style=color:#a6e22e>art</span><span style=color:#f92672>=</span><span style=color:#e6db74>pointer</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">115</span><span><span style=color:#a6e22e>nach</span><span style=color:#f92672>=</span><span style=color:#e6db74>80180068890B091808687047</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">116</span><span><span style=color:#a6e22e>spiele</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPR,BPG,BPE,AXP,AXV</span>
</span></span></code></pre></div><p>Just like the last header value we dealt with, we search for <code>80 18 00 68 89 0b 09 18 08 68 70 47</code> and read the next four bytes to get a pointer to <code>0x00486578</code>. At that address is a list of pointers for the different map banks:</p><table><thead><tr><th>Pointer</th><th>Map Bank</th></tr></thead><tbody><tr><td><code>0x00485d60</code></td><td>0</td></tr><tr><td><code>0x00485e44</code></td><td>1</td></tr><tr><td><code>0x00485e58</code></td><td>2</td></tr><tr><td><code>0x00485e6c</code></td><td>3</td></tr><tr><td><code>0x00485e84</code></td><td>4</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><p>Bank 0 contains most of the outdoor areas, including routes, cities, etc. Interior maps are in separate banks according to how you enter them. For example, bank 1 contains all of the interiors of Littleroot Town such as your house, your rival&rsquo;s house, and Birch&rsquo;s lab, while bank 2 contains the interiors for Oldale Town.</p><p>Looking back at the data for the map we&rsquo;re using, we had a bank number of <code>00</code> and a map number of <code>10</code>.</p><p>So let&rsquo;s go to the address of map bank 0: <code>0x00485d60</code>. It contains another list of pointers. The map number <code>10</code> is a hex value, so in base 10 it would be <code>16</code>. The seventeenth pointer in the list (because the list is zero-indexed) is <code>0x00482678</code>.</p><p>Each map data block is 28 bytes long. At that address, we find the following data:</p><p><code>64 bc 3e 08 c4 7f 52 08 ba bc 1e 08 24 68 48 08 67 01 11 00 10 00 02 03 00 00 0d 00</code></p><p>There is a lot of information included here:</p><table><thead><tr><th>Bytes</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>0-3</td><td>Map Data Pointer</td><td><code>64 bc 3e 08</code></td></tr><tr><td>4-7</td><td>Event Data Pointer</td><td><code>c4 7f 52 08</code></td></tr><tr><td>8-11</td><td>Map Scripts Pointer</td><td><code>ba bc 1e 08</code></td></tr><tr><td>12-15</td><td>Connections Pointer</td><td><code>24 68 48 08</code></td></tr><tr><td>16-17</td><td>Music Index</td><td><code>67 01</code></td></tr><tr><td>18-19</td><td>Map Pointer Index</td><td><code>11 00</code></td></tr><tr><td>20</td><td>Label Index</td><td><code>10</code></td></tr><tr><td>21</td><td>Visibility (Flash)</td><td><code>00</code></td></tr><tr><td>22</td><td>Weather</td><td><code>02</code></td></tr><tr><td>23</td><td>Map Type</td><td><code>03</code></td></tr><tr><td>24-25</td><td>Unknown/Padding</td><td><code>00 00</code></td></tr><tr><td>26</td><td>Show Label on Entry</td><td><code>0d</code></td></tr><tr><td>27</td><td>In-battle field id</td><td><code>00</code></td></tr></tbody></table><p>The only value we&rsquo;re really interested in right now is the Label Index, which is <code>10</code> (16 in base 10)</p><p>Now let&rsquo;s find the list of location names. Back to <code>AdvanceMap.ini</code> again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">164</span><span><span style=color:#66d9ef>[NamenHeader]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">165</span><span><span style=color:#a6e22e>art</span><span style=color:#f92672>=</span><span style=color:#e6db74>pointer</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">166</span><span><span style=color:#a6e22e>nach</span><span style=color:#f92672>=</span><span style=color:#e6db74>C078288030BC01BC00470000</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">167</span><span><span style=color:#a6e22e>spiele</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPE,AXP,AXV</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">168</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">169</span><span><span style=color:#66d9ef>[NamenHeader2]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">170</span><span><span style=color:#a6e22e>art</span><span style=color:#f92672>=</span><span style=color:#e6db74>pointer</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">171</span><span><span style=color:#a6e22e>nach</span><span style=color:#f92672>=</span><span style=color:#e6db74>AC470000AE470000B0470000</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">172</span><span><span style=color:#a6e22e>spiele</span><span style=color:#f92672>=</span><span style=color:#e6db74>BPR,BPG</span>
</span></span></code></pre></div><p>We want the location names for Emerald (<code>BPE</code>), so we&rsquo;ll use the value of <code>NamenHeader</code>, which is:</p><p><code>c0 78 28 80 30 bc 01 bc 00 47 00 00</code></p><p>Search for that header, and you&rsquo;ll find a pointer immediately after it: <code>0x005a147c</code>. That points to the list of locations, stored in eight-byte blocks. Seek forward 16 blocks (128 bytes) and read the next 8 bytes:</p><p><code>04 0a 01 01 fb 0b 5a 08</code></p><p>The second half of that data is a pointer to <code>0x005a0bfb</code>, where the actual location name is. The names in the list are of variable length, so you can&rsquo;t just read a set number of bytes and will have to read byte-by-byte until you reach the <code>ff</code> terminator:</p><p><code>cc c9 cf ce bf 00 a2 a1 a2</code> <del><code>ff</code></del></p><p>Decode this value with the <a href=https://bulbapedia.bulbagarden.com/wiki/Character_encoding_(Generation_III)>Character Map</a> and you get the actual name of this location: <code>ROUTE 101</code>.</p><p>And there you have it, the final piece of information we need. Now we know that the encounter table we found earlier is for Route 101. Hopefully you don&rsquo;t have a headache after all that, because I certainly do.</p></div></article></main></body></html>